# ✏️  My Java learning route!
记录我的Java学习之路！

## 1. Effetive java
- [Chapter 1 Introduction](effetiveJava/Chapter1/Introduction.md)
    - [Chapter 2 Creating and Destroying Objects](effetiveJava/Chapter1/)
    - [Item 1 Consider static factory methods instead of constructors](effetiveJava/Chapter2/Item1.md)
    - [Item 2 Consider a builder when faced with many constructor parameters](effetiveJava/Chapter2/Item2.md)
    - [Item 3: Enforce the singleton property with a private constructor or an enum type](effetiveJava/Chapter2/Item3.md)
    - [Item 4: Enforce noninstantiability with a private constructor](effetiveJava/Chapter2/Item4.md)
    - [Item 5: Prefer dependency injection to hardwiring resources](effetiveJava/Chapter2/Item5.md)
    - [Item 6: Avoid creating unnecessary objects](effetiveJava/Chapter2/Item6.md)
    - [Item 7: Eliminate obsolete object references](effetiveJava/Chapter2/Item7.md)
    - [Item 8: Avoid finalizers and cleaners](effetiveJava/Chapter2/Item8.md)
    - [Item 9: Prefer try with resources to try finally](effetiveJava/Chapter2/Item9.md)
- [Chapter 3. Methods Common to All Objects](effetiveJava/Chapter3/Item6.md)
    - [Chapter 3 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 10: Obey the general contract when overriding equals](effetiveJava/Chapter3/Item6.md)
    - [Item 11: Always override hashCode when you override equals](effetiveJava/Chapter3/Item6.md)
    - [Item 12: Always override toString](effetiveJava/Chapter3/Item6.md)
    - [Item 13: Override clone judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 14: Consider implementing Comparable](effetiveJava/Chapter3/Item6.md)
- [Chapter 4. Classes and Interfaces](effetiveJava/Chapter3/Item6.md)
    - [Chapter 4 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 15: Minimize the accessibility of classes and members](effetiveJava/Chapter3/Item6.md)
    - [Item 16: In public classes use accessor methods not public fields](effetiveJava/Chapter3/Item6.md)
    - [Item 17: Minimize mutability](effetiveJava/Chapter3/Item6.md)
    - [Item 18: Favor composition over inheritance](effetiveJava/Chapter3/Item6.md)
    - [Item 19: Design and document for inheritance or else prohibit it](effetiveJava/Chapter3/Item6.md)
    - [Item 20: Prefer interfaces to abstract classes](effetiveJava/Chapter3/Item6.md)
    - [Item 21: Design interfaces for posterity](effetiveJava/Chapter3/Item6.md)
    - [Item 22: Use interfaces only to define types](effetiveJava/Chapter3/Item6.md)
    - [Item 23: Prefer class hierarchies to tagged classes](effetiveJava/Chapter3/Item6.md)
    - [Item 24: Favor static member classes over nonstatic](effetiveJava/Chapter3/Item6.md)
    - [Item 25: Limit source files to a single top level class](effetiveJava/Chapter3/Item6.md)
- [Chapter 5. Generics](effetiveJava/Chapter3/Item6.md)
    - [Chapter 5 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 26: Do not use raw types](effetiveJava/Chapter3/Item6.md)
    - [Item 27: Eliminate unchecked warnings](effetiveJava/Chapter3/Item6.md)
    - [Item 28: Prefer lists to arrays](effetiveJava/Chapter3/Item6.md)
    - [Item 29: Favor generic types](effetiveJava/Chapter3/Item6.md)
    - [Item 30: Favor generic methods](effetiveJava/Chapter3/Item6.md)
    - [Item 31: Use bounded wildcards to increase API flexibility](effetiveJava/Chapter3/Item6.md)
    - [Item 32: Combine generics and varargs judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 33: Consider typesafe heterogeneous containers](effetiveJava/Chapter3/Item6.md)
- [Chapter 6. Enums and Annotations](effetiveJava/Chapter3/Item6.md)
    - [Chapter 6 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 34: Use enums instead of int constants](effetiveJava/Chapter3/Item6.md)
    - [Item 35: Use instance fields instead of ordinals](effetiveJava/Chapter3/Item6.md)
    - [Item 36: Use EnumSet instead of bit fields](effetiveJava/Chapter3/Item6.md)
    - [Item 37: Use EnumMap instead of ordinal indexing](effetiveJava/Chapter3/Item6.md)
    - [Item 38: Emulate extensible enums with interfaces](effetiveJava/Chapter3/Item6.md)
    - [Item 39: Prefer annotations to naming patterns](effetiveJava/Chapter3/Item6.md)
    - [Item 41: Use marker interfaces to define types](effetiveJava/Chapter3/Item6.md)
- [Chapter 7. Lambdas and Streams](effetiveJava/Chapter3/Item6.md)
    - [Chapter 7 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 42: Prefer lambdas to anonymous classes](effetiveJava/Chapter3/Item6.md)
    - [Item 43: Prefer method references to lambdas](effetiveJava/Chapter3/Item6.md)
    - [Item 44: Favor the use of standard functional interfaces](effetiveJava/Chapter3/Item6.md)
    - [Item 45: Use streams judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 46: Prefer side effect free functions in streams](effetiveJava/Chapter3/Item6.md)
    - [Item 47: Prefer Collection to Stream as a return type](effetiveJava/Chapter3/Item6.md)
    - [Item 48: Use caution when making streams parallel](effetiveJava/Chapter3/Item6.md)
- [Chapter 8. Methods](effetiveJava/Chapter3/Item6.md)
    - [Chapter 8 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 49: Check parameters for validity](effetiveJava/Chapter3/Item6.md)
    - [Item 50: Make defensive copies when needed](effetiveJava/Chapter3/Item6.md)
    - [Item 51: Design method signatures carefully](effetiveJava/Chapter3/Item6.md)
    - [Item 52: Use overloading judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 53: Use varargs judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 54: Return empty collections or arrays not nulls](effetiveJava/Chapter3/Item6.md)
    - [Item 55: Return optionals judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 56: Write doc comments for all exposed API elements](effetiveJava/Chapter3/Item6.md)
- [Chapter 9. General Programming](effetiveJava/Chapter3/Item6.md)
    - [Chapter 9 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 57: Minimize the scope of local variables](effetiveJava/Chapter3/Item6.md)
    - [Item 58: Prefer for each loops to traditional for loops](effetiveJava/Chapter3/Item6.md)
    - [Item 59: Know and use the libraries](effetiveJava/Chapter3/Item6.md)
    - [Item 60: Avoid float and double if exact answers are required](effetiveJava/Chapter3/Item6.md)
    - [Item 61: Prefer primitive types to boxed primitives](effetiveJava/Chapter3/Item6.md)
    - [Item 62: Avoid strings where other types are more appropriate](effetiveJava/Chapter3/Item6.md)
    - [Item 63: Beware the performance of string concatenation](effetiveJava/Chapter3/Item6.md)
    - [Item 64: Refer to objects by their interfaces](effetiveJava/Chapter3/Item6.md)
    - [Item 65: Prefer interfaces to reflection](effetiveJava/Chapter3/Item6.md)
    - [Item 66: Use native methods judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 67: Optimize judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 68: Adhere to generally accepted naming conventions](effetiveJava/Chapter3/Item6.md)
- [Chapter 10. Exceptions](effetiveJava/Chapter3/Item6.md)
    - [Chapter 10 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 69: Use exceptions only for exceptional conditions](effetiveJava/Chapter3/Item6.md)
    - [Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors](effetiveJava/Chapter3/Item6.md)
    - [Item 71: Avoid unnecessary use of checked exceptions](effetiveJava/Chapter3/Item6.md)
    - [Item 72: Favor the use of standard exceptions](effetiveJava/Chapter3/Item6.md)
    - [Item 73: Throw exceptions appropriate to the abstraction](effetiveJava/Chapter3/Item6.md)
    - [Item 74: Document all exceptions thrown by each method](effetiveJava/Chapter3/Item6.md)
    - [Item 75: Include failure capture information in detail messages](effetiveJava/Chapter3/Item6.md)
    - [Item 76: Strive for failure atomicity](effetiveJava/Chapter3/Item6.md)
    - [Item 77: Don’t ignore exceptions](effetiveJava/Chapter3/Item6.md)
- [Chapter 11. Concurrency](effetiveJava/Chapter3/Item6.md)
    - [Chapter 11 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 78: Synchronize access to shared mutable data](effetiveJava/Chapter3/Item6.md)
    - [Item 79: Avoid excessive synchronization](effetiveJava/Chapter3/Item6.md)
    - [Item 80: Prefer executors, tasks, and streams to threads](effetiveJava/Chapter3/Item6.md)
    - [Item 81: Prefer concurrency utilities to wait and notify](effetiveJava/Chapter3/Item6.md)
    - [Item 82: Document thread safety](effetiveJava/Chapter3/Item6.md)
    - [Item 83: Use lazy initialization judiciously](effetiveJava/Chapter3/Item6.md)
    - [Item 84: Don’t depend on the thread scheduler](effetiveJava/Chapter3/Item6.md)
- [Chapter 12. Serialization](effetiveJava/Chapter3/Item6.md)
    - [Chapter 12 Introduction](effetiveJava/Chapter3/Item6.md)
    - [Item 85: Prefer alternatives to Java serialization](effetiveJava/Chapter3/Item6.md)
    - [Item 86: Implement Serializable with great caution](effetiveJava/Chapter3/Item6.md)
    - [Item 87: Consider using a custom serialized form](effetiveJava/Chapter3/Item6.md)
    - [Item 88: Write readObject methods defensively](effetiveJava/Chapter3/Item6.md)
    - [Item 89: For instance control prefer enum types to readResolve](effetiveJava/Chapter3/Item6.md)
    - [Item 90: Consider serialization proxies instead of serialized instances](effetiveJava/Chapter3/Item6.md)
